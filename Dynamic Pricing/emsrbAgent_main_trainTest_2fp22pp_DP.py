# This script is used to test and record the performance of an EMSRb agent in the ARM-DP problem
# Author: Syed A.M. Shihab

import pickle
import sys
import numpy as np
import scipy.io

from revpy.revpy import protection_levels
from revpy.helpers import cumulative_booking_limits
from revpy.fare_transformation import calc_fare_transformation

from emsrbAgent_loggerClass_DP import *

maxBumpingCost = 6.75
bcfArray = [2] # [2.0, 2.5]
cncArray = [1] # [1,2,3] # [4] # [1] # [ 2 3]
fdArray = [1] # [1,2,3] # [4] # [3] # [1]
nTestEps = 2000 # 5000 # 150

# TODO: revpy with poisson
# TODO: update EMSRb agent's market parameters after every 50 flight episodes


f = open("EMSRbAgent_numExpResults.txt", "w")
f.write("bumpingCostFactor, cancelProbsSetting, meanNarrivalsSetting, mean test RP, mean test LF" + "\n")

for bumpingCostFactor in bcfArray:
    for cancelProbsSetting in cncArray:
        for meanNarrivalsSetting in fdArray:

            print('cancelProbsSetting =', cancelProbsSetting)
            print('meanNarrivalsSetting =', meanNarrivalsSetting)
            overbooking_cost_multiplier = bumpingCostFactor
                               
            testData = "testData_cnc" + repr(cancelProbsSetting) + "_fcArrivals" + repr(meanNarrivalsSetting) + '_2fp22pp_true_mktSiml' + ".mat"
##            fileName = 'testData_cnc' + string(cancelProbsSetting) + '_fcArrivals' + string(meanNarrivalsSetting) + '_2fp22pp_true_mktSiml'; % to generate test data, comment out the 

            mat = scipy.io.loadmat(testData, squeeze_me=True)

            nFareProducts = mat['nFareProducts']
            nWTPgroups = mat['nWTPgroups']
            fareLevels = mat['fareLevels']
            
            #################################################################################################################################################################################
            nFareClasses = nWTPgroups # fClass = WTPgroup
            #################################################################################################################################################################################
            fProductIdentifierPy = mat['fProductIdentifierPy']
            capacity = mat['capacity']
            totalTime = mat['bookingHorizon']                         
            # fclassIdentifierPy = mat['fclassIdentifierPy']            
            cncFee = mat['cncFee']
            wtp = mat['wtp']
            fClassPrices = mat['fareLevels']
            trDataPy = mat['trDataPy']
            # nArrivals_by_eps_fClass = mat['nArrivals_by_eps_wtpGroup']
            max_reward_list = mat['maxRevenue_eps'] # 'maxReward'
            
            nCancellations_price = np.zeros((nFareClasses-2), dtype=int) # nCancellations_price = ([0,0]);
            cancellations = []

            done = False

            # Using market parameter estimates derived from historical flight episode data generated by the true market simulator
            # loading 'mktParameterEstimates.mat'
            mat = scipy.io.loadmat('mktParameterEstimates.mat', squeeze_me=True)
            updateInterval_mktParameters = 50
            # fClassMeanArrivals = mat['fClassMeanArrivals']
            lambdaValues = mat['lambdaValues_est'] # update after every 50 flight episodes           
            cncProb_fClass_t = mat['cncProb_wtpGroups_est'] # update after every 50 flight episodes
            prevSum_nArrvials_wtpGrp_t = mat['sum_nArrvials_wtpGrp_t'] # update after every 50 flight episodes
            prevSum_cncRate_wtpGrp_t = mat['sum_cncRate_wtpGrp_t'] # update after every 50 flight episodes
            nEpisodes = mat['nEpisodes'] # update after every 50 flight episodes
##            cncProb_fClass_t = np.vstack ((cncProb_fClass_t, np.array([[0]*182]), np.array([[0]*182])))  

            testLogger = infoLogger_emsrb()

###################################################################################################################################################################
            # variables related to updating market parameters
            # newSum_lambdaValues_wtpGrp_t = np.zeros((nWTPgroups,182))
            running_nObs_PaxArv_wtpGrp_t = np.zeros((nWTPgroups,182))
            runningSum_nArv_wtpGrp_t = np.zeros((nWTPgroups,182))
            runningSum_cncRate_wtpGrp_t = np.zeros((1,182))
            # running_nObs_PaxCnc_wtpGrp_t = np.zeros((nWTPgroups,182))
###################################################################################################################################################################
            

            for currentEpisodeIndex in range(nTestEps):

###################################################################################################################################################################
                if ((currentEpisodeIndex+1)%updateInterval_mktParameters==0):
                    print('current episode index: ',currentEpisodeIndex)
                    # updating market parameters by computing new averages using new observations
                    lambdaValues[0] = (prevSum_nArrvials_wtpGrp_t[0] + runningSum_nArv_wtpGrp_t[0])/(nEpisodes/2 + running_nObs_PaxArv_wtpGrp_t[0])  
                    lambdaValues[1] = (prevSum_nArrvials_wtpGrp_t[1] + runningSum_nArv_wtpGrp_t[1])/(nEpisodes/2 + running_nObs_PaxArv_wtpGrp_t[1]) - lambdaValues[0]

                    lambdaValues[2] = (prevSum_nArrvials_wtpGrp_t[2] + runningSum_nArv_wtpGrp_t[2])/(nEpisodes/2 + running_nObs_PaxArv_wtpGrp_t[2])
                    lambdaValues[3] = (prevSum_nArrvials_wtpGrp_t[3] + runningSum_nArv_wtpGrp_t[3])/(nEpisodes/2 + running_nObs_PaxArv_wtpGrp_t[3]) - lambdaValues[2]

                    lambdaValues[lambdaValues < 0] = 0

                    cncProb_fClass_t[0] = (prevSum_cncRate_wtpGrp_t[0] + runningSum_cncRate_wtpGrp_t[0])/(nEpisodes/2 + currentEpisodeIndex) # running_nObs_PaxCnc_wtpGrp_t[0])
                    cncProb_fClass_t[1] = cncProb_fClass_t[0]
                    # cncProb_fClass_t[2] = cncProb_fClass_t[3] = np.zeros((1,182))
###################################################################################################################################################################

                    
                # new episode
                testLogger.on_episode_begin(currentEpisodeIndex)

                # env.reset()
                # reseting variables and loading episode info; env.reset()
                currentEpisode = trDataPy[currentEpisodeIndex]
                episode_reward = 0
                max_reward = max_reward_list[currentEpisodeIndex] # theoretical upper bound of revenue/theoretical optimal revenue                
                nSeatsAvailable = capacity # All seats are available for booking at time=0
                                
                paxIndex = 0
                nTotalPax = currentEpisode.shape[0] 
                
                # nBookings_fClass = np.zeros(nFareClasses, dtype=int) # nBookings_fClass = [0 0 0 0]
                nCancellations_price = np.zeros(nFareClasses-2, dtype=int) # last two wtpGroups do not have the option of canceling their ticket
                bumpingCost = 0
                nBookings_fp = np.zeros(nFareProducts, dtype=int) # nBookings_fp = [0 0 0]
                nBookings_price = np.zeros(nWTPgroups, dtype=int) # nBookings_fClass = nBookings_price
                preBumping_nBookings_fp = np.zeros(nFareProducts, dtype=int)
                preBumping_nBookings_price = np.zeros(nWTPgroups, dtype=int)
                

                cancellations = [] # empty list

                done = False 
                
                # env.step()
                for time in range(totalTime): 
                    # new step
                    
                    timeRem = totalTime - time
                    
                    ## determining the booking limits of each fare class (fare product-price combination) using the EMSRb method
                    # deteriming the expected demand and cancellation forecasts of each fare class for the remaining time of the booking period
                    demandForecast_fClass = np.zeros((nFareClasses))
                    cncForecast_fClass = np.zeros((nFareClasses))
                    # At any given time, demand forecast of each fare class for the remaining time period depends on the expected number of future arrivals and cancellations at each subsequent time step                    
                    for fClassInd in range(nFareClasses):
                        changeInB = 0 # this variable stores the expected changeInB at time = timeInd (see the for-loop below)
                        b_fClass_t = nBookings_price[fClassInd] # Final value of this variable = expected b_fClass_182; nBookings_fClass[fClassInd] = current booking level in fClass given by fClassInd (at t = time)
                        nCnc = 0
                        # nArv = 0
                        for timeInd in range(time,totalTime):
                            nCnc = nCnc + b_fClass_t*cncProb_fClass_t[fClassInd,timeInd]                            
                            changeInB = -b_fClass_t*cncProb_fClass_t[fClassInd,timeInd]+lambdaValues[fClassInd,timeInd] # alternative equation: changeInB = changeInB - b_fClass_t*cncProb_fClass_t[fClassInd,timeInd]+lambdaValues[fClassInd,timeInd]
                            b_fClass_t = b_fClass_t + changeInB # alternative equation: b_fClass_t = nBookings_fClass[fClassInd] + changeInB
                        # nArv = np.sum(lambdaValues[fClassInd,time:]) # expected number of future arrivals
                        demandForecast_fClass[fClassInd] = np.sum(lambdaValues[fClassInd,time:]) # alternative equation: demandForecast_fClass[fClassInd] = changeInB
                        cncForecast_fClass[fClassInd] = nCnc


                    # Determining EMSRb agent's action in the current time step
                    paxCount = np.zeros(nFareClasses, dtype=int)
                    
                    AUcapacity = int(nSeatsAvailable + np.sum(cncForecast_fClass))

                    p = protection_levels(fClassPrices, demandForecast_fClass, method='EMSRb')        
                
                    BLemsrb = cumulative_booking_limits(p, AUcapacity) # proxy for the action of closing fare classes; bookingLimits varies from flight episode to episode based on stochastic demand

                    openClose_WTPgrpFC = [0,0,0,0] # 0 = closed, 1 = open                    
                    for fClassInd in [1,3]:
                        if BLemsrb[fClassInd]>0:
                            openClose_WTPgrpFC[fClassInd]=1
                        else:
                            if BLemsrb[fClassInd-1]>0:
                                openClose_WTPgrpFC[fClassInd-1]=1

                    prices_fp = np.zeros((2))
                    fpInd=0
                    if openClose_WTPgrpFC[1]==0:
                       prices_fp[fpInd] = fClassPrices[0] # higher price
                    else:
                       prices_fp[fpInd] = fClassPrices[1] # lower price

                    fpInd=1
                    if openClose_WTPgrpFC[3]==1:
                        prices_fp[fpInd] = fClassPrices[3] # lower price
                    else:
                        if openClose_WTPgrpFC[2]==1: 
                            prices_fp[fpInd] = fClassPrices[2] # higher price
                        else:
                            prices_fp[fpInd] = np.inf # fp closed                   
                    


###################################################################################################################################################################
                    # variables related to updating market parameters
                    # nnewSum_lambdaValues_wtpGrp_t = np.zeros(nWTPgroups,182)
                    # nArvAtT_wtpGrp = np.zeros(nWTPgroups)

                    # determining which group of passengers is arriving for high fare product: wtpGrp0 or (wtpGrp0 + wtpGrp1)
                    fareInd = np.where(fareLevels == prices_fp[0])[0][0]
                    running_nObs_PaxArv_wtpGrp_t[fareInd][time] += 1

                    # determining which group of passengers is arriving for low fare product: wtpGrp2 or (wtpGrp2 + wtpGrp3) or no passengers at all if fp is closed
                    if prices_fp[1]<10: # !=np.inf:                        
                        fareInd = np.where(fareLevels == prices_fp[1])[0][0]
                        running_nObs_PaxArv_wtpGrp_t[fareInd][time] += 1

                    nBookings_atTminus1_Hfp = nBookings_fp[0]                    
###################################################################################################################################################################

                    reward = 0 # step reward
                    # Checking if there are pax arriving at this time step                               
                    # action = {0,...,6}                                                        
                    arvTime = currentEpisode[paxIndex,0]
                    while (arvTime==time): # pax arrives within this time step

                        wtpGroup = int(currentEpisode[paxIndex,1]) # wtpGroup = {0,1,2,3,4,5}
                        fproduct = fProductIdentifierPy[wtpGroup] # fProductIdentifierPy = {0,1,2}
                        cncTime = currentEpisode[paxIndex,2]
                        # Determining if pax will buy ticket at the current price - depends on pax's wtpGroup, fproduct and fproduct_price charged
                        if (wtp[wtpGroup]>=prices_fp[fproduct]): # pax buys the ticket
                            nBookings_fp[fproduct] += 1 # fproduct = fare class of passenger who booked the ticket = {0,1,2}
                            farePaid = prices_fp[fproduct]
                            nBookings_price[np.where(fareLevels == farePaid)[0][0]] += 1 
                            # Computing immediate reward
                            reward += farePaid


###################################################################################################################################################################
                            fareInd = np.where(fareLevels == farePaid)[0][0]
                            # variables related to updating market parameters                            
##                            if fProduct==1: # low fp
##                                if prices_fp[fproduct]==fareLevels[2]: # high price
##                                    nArv_wtpGrp_t[2][time] += 1
                            runningSum_nArv_wtpGrp_t[fareInd][time] += 1
###################################################################################################################################################################
                            

                            # Checking if passenger will cancel reservation later on
                            if (cncTime > -1):
                                cancellations.append((cncTime, fproduct, farePaid))
                                # sort on first index (cancellation time)
                                cancellations.sort(key= lambda elem: elem[0])
            ##                else: # pax will not cancel
            ##                    priceInd = np.where(fareLevels == farePaid)
            ##                    nBookings_price[priceInd[0][0]] += 1 # At the end of the episode, sum(nBookings_fp) = sum(nBookings_price) 
                        
                        # Move on to next pax
                        if(paxIndex < nTotalPax - 1):
                            paxIndex += 1
                            arvTime = currentEpisode[paxIndex,0]
                        else:
                            arvTime = -1 # break while loop

###################################################################################################################################################################
                    nCncAtT_wtpGrp = np.zeros(2)
###################################################################################################################################################################
                    # removing any cancellations that occur during this time step
                    while((len(cancellations) > 0) and (cancellations[0][0] == time)):
                        fproductCnc = cancellations[0][1]
                        farePaid = cancellations[0][2]
                        nBookings_fp[fproductCnc] -= 1
                        fareInd = np.where(fareLevels == farePaid)[0][0]
                        nBookings_price[fareInd] -= 1
                        nCancellations_price[fareInd] += 1
###################################################################################################################################################################
                        nCncAtT_wtpGrp[fareInd] += 1
###################################################################################################################################################################
                        # Computing reward
                        reward -= (farePaid - cncFee[fproductCnc]) # fproductCancelRefund[fproductCnc]*fproductPrices[fproductCnc]
                        # Removing first element of the stack
                        cancellations.pop(0)


###################################################################################################################################################################
                    if nBookings_atTminus1_Hfp>0:
                        runningSum_cncRate_wtpGrp_t[0][time] += np.sum(nCncAtT_wtpGrp)/nBookings_atTminus1_Hfp
###################################################################################################################################################################
                                                     
        
                    if (time==totalTime-1): # if time == 181
                        done = True
                        

                    if (done):
                        
                        # computing bumping cost
                        preBumping_nBookings_fp = nBookings_fp
                        preBumping_nBookings_price = nBookings_price
                        
                        overbooking = 0
                        if(sum(nBookings_fp) > capacity): # Oversold/overbooked flight
                            nPaxToBump = sum(nBookings_fp) - capacity # number of passengers that need to voluntarily/involuntarily denied boarding
                            overbooking = nPaxToBump
                            # first bump pax who paid the lowest fare 
                            # if(nPaxToBump <= nBookings_fp[2]): # if(nPaxToBump <= nBookings_fp[5]):
                            if(nPaxToBump <= nBookings_price[nWTPgroups-1]): # if(nPaxToBump <= nBookings_fp[3]):
                                nBookings_fp[nFareProducts-1] -= nPaxToBump
                                nBookings_price[nWTPgroups-1] -= nPaxToBump
                                # Assuming the scheduled flight is a domestic one and bumped pax will experience 1 to 2 hour arrival delay
                                reward -= min(overbooking_cost_multiplier*fareLevels[nWTPgroups-1],675/100)*nPaxToBump # DBC - Denied Boarding Compensation
                                bumpingCost += min(overbooking_cost_multiplier*fareLevels[nWTPgroups-1],675/100)*nPaxToBump # DBC - Denied Boarding Compensation
                            elif((nPaxToBump-nBookings_price[nWTPgroups-1]) <= nBookings_price[nWTPgroups-2]):
                                # first bump all pax of lowest wtpGroup
                                reward -= min(overbooking_cost_multiplier*fareLevels[nWTPgroups-1],675/100)*nBookings_price[nWTPgroups-1]
                                bumpingCost += min(overbooking_cost_multiplier*fareLevels[nWTPgroups-1],675/100)*nBookings_price[nWTPgroups-1]
                                nPaxToBump -= nBookings_price[nWTPgroups-1]                                        
                                nBookings_fp[nFareProducts-1] -= nBookings_price[nWTPgroups-1]
                                nBookings_price[nWTPgroups-1] = 0
                                # then bump pax of second lowest wtpGroup until nPaxOnBoard = capacity
                                reward -= min(overbooking_cost_multiplier*fareLevels[nWTPgroups-2],675/100)*nPaxToBump
                                bumpingCost += min(overbooking_cost_multiplier*fareLevels[nWTPgroups-2],675/100)*nPaxToBump
                                nBookings_fp[nFareProducts-1] -= nPaxToBump
                                nBookings_price[nWTPgroups-2] -= nPaxToBump
                            elif((nPaxToBump-nBookings_price[nWTPgroups-1]-nBookings_price[nWTPgroups-2]) <= nBookings_price[nWTPgroups-3]):
                                # first bump all pax of lowest fare class (lowest two wtpGroups)
                                reward -= min(overbooking_cost_multiplier*fareLevels[nWTPgroups-1],675/100)*nBookings_price[nWTPgroups-1]
                                bumpingCost += min(overbooking_cost_multiplier*fareLevels[nWTPgroups-1],675/100)*nBookings_price[nWTPgroups-1]
                                nPaxToBump -= nBookings_price[nWTPgroups-1]
                                nBookings_price[nWTPgroups-1] = 0
                                fproduct = fProductIdentifierPy[nWTPgroups-1]
                                nBookings_fp[fproduct] -= nBookings_price[nWTPgroups-1]
                                
                                reward -= min(overbooking_cost_multiplier*fareLevels[nWTPgroups-2],675/100)*nBookings_price[nWTPgroups-2]
                                bumpingCost += min(overbooking_cost_multiplier*fareLevels[nWTPgroups-2],675/100)*nBookings_price[nWTPgroups-2]
                                nPaxToBump -= nBookings_price[nWTPgroups-2]
                                nBookings_price[nWTPgroups-2] = 0
                                fproduct = fProductIdentifierPy[nWTPgroups-2]
                                nBookings_fp[fproduct] -= nBookings_price[nWTPgroups-2]
                                # then bump pax of third lowest wtpGroup until nPaxOnBoard = capacity
                                reward -= min(overbooking_cost_multiplier*fareLevels[nWTPgroups-3],675/100)*nPaxToBump
                                bumpingCost += min(overbooking_cost_multiplier*fareLevels[nWTPgroups-3],675/100)*nPaxToBump
                                nBookings_price[nWTPgroups-3] -= nPaxToBump
                                fproduct = fProductIdentifierPy[nWTPgroups-3]
                                nBookings_fp[fproduct] -= nPaxToBump
                            # TODO: add another elif
                       
                                        
                                        
                    
                    observation = (time+1, list(nBookings_price), list(nCancellations_price))
                    
                    
                    nSeatsAvailable = capacity - sum(nBookings_price) # updating nSeatsAvailable                            

                    episode_reward += reward
                    
                    # print('testLogger.observations[currentEpisodeIndex] =',testLogger.observations[currentEpisodeIndex],'\n')
                    testLogger.on_step_end(currentEpisodeIndex, observation, reward, openClose_WTPgrpFC, BLemsrb, prices_fp)
                    
                testLogger.on_episode_end(nBookings_fp, nBookings_price, preBumping_nBookings_fp, preBumping_nBookings_price, bumpingCost, nCancellations_price, episode_reward, max_reward, overbooking, capacity) 
                
                
            

            ##t1 = np.arange(nTestEpisodes)+1
            ##t2 = np.arange(1+(rmInterval-1)/2, nTestEpisodes+1-(rmInterval-1)/2)
            rP = np.array(testLogger.rewardPercentage)*100
            # aP = np.array(test_logger.acceptPercentage)*100
            LF = np.array(testLogger.loadFactor)*100
            # np.savez(outputDir + '/TrainingData.npz', rP=rP, aP=aP, LF=LF)

##            print('avgOptimalRevenuePercentage = ' + repr(np.mean(rP)))
##            # print('average_ap = ' + repr(np.mean(aP)))
##            print('avgLoadFactor = ' + repr(np.mean(LF)))

            print('avgOptimalRewardPercentage of best model in the last 300 episodes = ' + repr(np.mean(rP[-300:])))
            print('avgLoadFactor of best model in the last 300 episodes = ' + repr(np.mean(LF[-300:])))

            pklFilename = "emsrbAgent_testLogger_cnc" + repr(cancelProbsSetting) + "_fcArrivals" + repr(meanNarrivalsSetting) + '_2fp22pp_testedWith_true_mktSiml' + ".pkl"            
            with open(pklFilename, 'wb') as pklFilePointer:
                pickle.dump([testLogger.nBookings_fp, testLogger.nBookings_price, testLogger.preBumping_nBookings_fp, testLogger.preBumping_nBookings_price, testLogger.bumpingCost, testLogger.nCancellations_price,
                             testLogger.episode_reward, testLogger.max_reward, testLogger.rewardPercentage, testLogger.overbooking,
                             testLogger.loadFactor, testLogger.observations, testLogger.rewards, testLogger.prices_fp, testLogger.openClose_WTPgrpFC, testLogger.BLemsrb], pklFilePointer)
###################################################################################################################################################################
            with open("EMSRbAgent_mktEstimatesLatest.pkl", 'wb') as pklFilePointer2:
                pickle.dump([lambdaValues, cncProb_fClass_t, prevSum_nArrvials_wtpGrp_t + runningSum_nArv_wtpGrp_t, prevSum_cncRate_wtpGrp_t + runningSum_cncRate_wtpGrp_t, nEpisodes, running_nObs_PaxArv_wtpGrp_t, currentEpisodeIndex], pklFilePointer2)
##
##            mat = scipy.io.loadmat('mktParameterEstimates.mat', squeeze_me=True)
##            self.updateInterval_mktParameters = 50        
##            self.EMSRbagent_est_lambdaValues = mat['lambdaValues_est'] # update after every 50 flight episodes           
##            self.EMSRbagent_est_cncProb_fClass_t = mat['cncProb_wtpGroups_est'] # update after every 50 flight episodes
##            self.prevSum_nArrvials_wtpGrp_t = mat['sum_nArrvials_wtpGrp_t'] # update after every 50 flight episodes
##            self.prevSum_cncRate_wtpGrp_t = mat['sum_cncRate_wtpGrp_t'] # update after every 50 flight episodes
##            self.nHistEpisodes = mat['nEpisodes'] # update after every 50 flight episodes
##
##            lambdaValues = mat['lambdaValues_est'] # update after every 50 flight episodes           
##            cncProb_fClass_t = mat['cncProb_wtpGroups_est'] # update after every 50 flight episodes
##            prevSum_nArrvials_wtpGrp_t = mat['sum_nArrvials_wtpGrp_t'] # update after every 50 flight episodes
##            prevSum_cncRate_wtpGrp_t = mat['sum_cncRate_wtpGrp_t'] # update after every 50 flight episodes
##            nEpisodes = mat['nEpisodes'] # update after every 50 flight episodes
##
##            lambdaValues[0] = (prevSum_nArrvials_wtpGrp_t[0] + runningSum_nArv_wtpGrp_t[0])/(nEpisodes/2 + running_nObs_PaxArv_wtpGrp_t[0])  
##            lambdaValues[1] = (prevSum_nArrvials_wtpGrp_t[1] + runningSum_nArv_wtpGrp_t[1])/(nEpisodes/2 + running_nObs_PaxArv_wtpGrp_t[1]) - lambdaValues[0]
##
##            lambdaValues[2] = (prevSum_nArrvials_wtpGrp_t[2] + runningSum_nArv_wtpGrp_t[2])/(nEpisodes/2 + running_nObs_PaxArv_wtpGrp_t[2])
##            lambdaValues[3] = (prevSum_nArrvials_wtpGrp_t[3] + runningSum_nArv_wtpGrp_t[3])/(nEpisodes/2 + running_nObs_PaxArv_wtpGrp_t[3]) - lambdaValues[2]
##
##            lambdaValues[lambdaValues < 0] = 0
##
##            cncProb_fClass_t[0] = (prevSum_cncRate_wtpGrp_t[0] + runningSum_cncRate_wtpGrp_t[0])/(nEpisodes/2 + currentEpisodeIndex) # running_nObs_PaxCnc_wtpGrp_t[0])
##            cncProb_fClass_t[1] = cncProb_fClass_t[0]
##            # cncProb_fClass_t[2] = cncProb_fClass_t[3] = np.zeros((1,182))
###################################################################################################################################################################
            f.write(repr(bumpingCostFactor) + ", ")
            f.write(repr(cancelProbsSetting) + ", ")
            f.write(repr(meanNarrivalsSetting) + ", ")
            f.write(repr(np.mean(rP)) + ", ")
            f.write(repr(np.mean(LF)) + "\n")

f.close()
